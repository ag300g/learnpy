# 装饰器的作用就是为已经存在的对象添加额外的功能。
下面分步骤举例说明
### 1. 函数是可以作为参数传递给另一函数的
- e.g.
```python
def foo():
    print("i am an specific expression in foo")

def bar(func):
    func()
    print("i am an specific expression in bar")
    
bar(foo)

```
- 运行结果为
```
i am an specific expression in foo
i am an specific expression in bar
```


### 2. 现在三个函数已经在系统中正常运行, 现在想要为每个函数加一个打印`=`的需求, 一般的实现方式
- 已有函数
```python
def foo1():
    print("i am an specific expression in foo1")
    
def foo2():
    print("i am an specific expression in foo2")
    
def foo3():
    print("i am an specific expression in foo3")
```

- 一般实现方式
```python
def foo1():
    print("===================================")
    print("i am an specific expression in foo1")
    
def foo2():
    print("===================================")
    print("i am an specific expression in foo2")
    
def foo3():
    print("===================================")
    print("i am an specific expression in foo3")
```
- 这种方式实现会造成大量雷同的代码，在要改动的函数多的时候很麻烦
- 为了减少重复写代码，我们可以重新定义一个新的函数：专门打印`=`, 把业务代码包到这个函数里面

### 3. 现在三个函数已经在系统中正常运行, 现在想要为每个函数加一个打印`=`的需求, 更加面向对象的实现方式
- 新定义一个函数`add_equals`：专门打印`=`
```python
  def add_equals(func):
    print("===================================")
    func()

add_equals(foo1)
add_equals(foo2)
add_equals(foo3)
```
- 这样做逻辑上没问题，功能也都能够实现
- 但这么做的问题, 下游调用`foo1`,`foo2`,`foo3`的函数, 都要改成调用`add_equals(foo1)`了, 这就破坏了原有的代码结构
- 有没有更好的方式的呢？当然有，答案就是装饰器

### 4. 简单装饰器的实现方式
- 定义一个装饰器函数`wrapper`, 所需功能在这个装饰器函数本身实现, `add_equals`的返回值是这个装饰器函数本身
```python
def add_equals(func):

    def wrapper():
        print("===================================")
        return func()   # 把 foo 当做参数传递进来时，执行 func() 就相当于执行 foo()

    return wrapper

foo1 = add_equals(foo1)  # 因为装饰器 add_equals(foo1) 返回的时函数对象 wrapper，这条语句相当于  foo1 = wrapper
foo2 = add_equals(foo2)  # 因为装饰器 add_equals(foo1) 返回的时函数对象 wrapper，这条语句相当于  foo1 = wrapper
foo3 = add_equals(foo3)  # 因为装饰器 add_equals(foo1) 返回的时函数对象 wrapper，这条语句相当于  foo1 = wrapper
foo1()  
foo2()
foo3()  
```
- 这样就可以实现不改变下游代码并且增加原有函数的功能


### 5. 更优雅的实现方式: 语法糖

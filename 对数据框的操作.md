### 查看数据框的基本信息
1. 查看各列的数据属性`print(df.dtypes)`
2. 查看列名`df.columns.tolist()`
3. 查看行名`df.index.tolist()`
4. 查看维度信息`df.shape`
> 查看行数`df.shape[0]` / `len(df)`

> 查看列数`df.shape[1]`

### 按列聚合`groupby()`
1. 按照一列聚合
```python
dic1 = {'a': [1, 1, 1, 2, 2, 2], 'b': [2, 3, 4, 2, 3, 4], 'c': ['s', 's', 's', 's', 's', 's'], 'd': [6, 5, 4, 3, 2, 1]}
type(dic1)
df1 = pd.DataFrame(dic1)
df2 = df1.groupby(['b']) ## 把df1按照第二列聚合
df3 = df2.max()
```
> - 这时聚合的结果df2是一种特殊数据类型groupby类型
> - 如果要查看聚合结果, 必须要有聚合函数`max,min,sum,count,mean,median`等
> - df3是数据框

2. 按照某几列聚合
```python
dic1 = {'a': [1, 1, 1, 2, 2, 2], 'b': [2, 3, 4, 2, 3, 4], 'c': [1, 1, 2, 2, 3, 3], 'd': [6, 5, 4, 3, 2, 1]}
type(dic1)
df1 = pd.DataFrame(dic1)
df2 = df1.groupby(['a','c']) ## 把df1按照第二列聚合
df3 = df2.count()
df3.index.tolist()
df3.columns.tolist()
```
> df3是数据框, 行名是(a,c)分别对应的值`[(1, 1), (1, 2), (2, 2), (2, 3)]`, 列名是`['b', 'd']`

3. 聚合后的数据有一个问题就是, groupby的列跑的行名上了, 为了使结果数据框的列和原始数据框的列一致
```python
dic1 = {'a': [1, 1, 1, 2, 2, 2], 'b': [2, 3, 4, 2, 3, 4], 'c': [1, 1, 2, 2, 3, 3], 'd': [6, 5, 4, 3, 2, 1]}
type(dic1)
df1 = pd.DataFrame(dic1)
df2 = df1.groupby(['a','c']) ## 把df1按照第二列聚合
df3 = df2.count()

# 第一种实现方式
df4 = df3.reset_index()

# 第二种实现方式
df3.reset_index(inplace=True)
```



### 3. 把数据框的内容存入excel
```python
## test for to_excel
import pandas as pd
import numpy as np
a = np.array(np.arange(12)).reshape(4,3)
b = {'a':[1,2,3,4], 'b':[5,6,7,8], 'c':[9,10,11,12], 'd':[13,14,15,16]}
df1 = pd.DataFrame(a)
df2 = pd.DataFrame(b)

writer = pd.ExcelWriter('output.xlsx')
df1.to_excel(writer,'Sheet1')
df2.to_excel(writer,'Sheet2')
# sheet1 and sheet2 can changed to any sheet names
writer.save()
```


### 4. 数据框相关-常用技巧
1. 修正行索引`df.reset_index(inplace=True)`
> 在进行完行选择选出子集以后，可以修正行索引

> 很多方法在加上`inplace=True`以后，可以对前面的对象直接操作而不是返回一个操作后的对象


2. 行转列`df.pivot(index='ProductDesc', columns='AttributeKey', values='AttributeValueKey')`
### 1. Make a script both importable and executable
> 使得一个脚本既能直接运行出结果, 又能再被import时不运行, 仅仅当成一个函数包

```python
if __name__ == '__main__':
    main()
```
> 调试代码的时候，在`if __name__ == '__main__'`中加入一些我们的调试代码，我们可以让外部模块调用的时候不执行我们的调试代码，但是如果我们想排查问题的时候，直接执行该模块文件，调试代码能够正常运行！

### 2. 使得打印结果更具可读性
```python
from pprint import pprint
pprint(df.head(10))
```
> 使用depth参数可以控制美观打印机递归处理嵌套数据结构的深度。输出中未包含的层次由一个省略号表示

### 3. 矩阵点乘`np.multiply()`与普通乘法`*`的区别
> 与乘法`*`相同

```python
import numpy as np
import pandas as pd
x1 = np.arange(9.0).reshape((3, 3))
x2 = np.arange(3.0)
x3 = np.arange(9.0,0).reshape((3, 3))
x4 = pd.DataFrame(x1)
print(np.multiply(x1, x2))
print(x1*x2)
## 以上两项结果相同, 皆为矩阵的每一列和x2点乘

print(np.multiply(x1, x3))
print(x1*x3)
## 以上两项结果相同, 皆为两个矩阵对应元素分别相乘
```

> 与乘法`*`不同

```python
x1 = [1,2,3,4,5]
x2 = [x * 10 for x in x1]
print(np.multiply(x1,2))
print(x1*2)
"""
---------------------------------------
以上两项结果不同, 分别为:
[ 2  4  6  8 10]
[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]
由此可见在进行点乘时, 如果数据结构存在变数
使用multiply是最为稳妥的方式
--------------------------------------
"""
```


### 随机
1. 打乱顺序
```python
import random
lll = list(range(20))
random.shuffle(lll)
```

2. 从一个集合中随机抽出n个
```python
import random
### 从0~99中随机抽出10个数(无放回)
lll = random.sample(range(100),10)

### 从0~99中随机抽出10个数(有放回)
lll = random.choices(range(100),k=10)
```

3. 从某个分布中随机取数
```python
### 从一个均匀分布中取出n个数
lll = random.uniform(10, 20) # 均匀分布为 10<=n<=20

### 从[0,1]均匀分布中随机取一个数
lll = random.random()

### 从一个标准正态分布中取出n个数
lll = random.gauss(0,1)

```
### 1. Make a script both importable and executable
> 使得一个脚本既能直接运行出结果, 又能再被import时不运行, 仅仅当成一个函数包

```python
def userdefined():
    ***
    ***

if __name__ == '__main__':
    userdefined()
```
> 调试代码的时候，在`if __name__ == '__main__'`中加入一些我们的调试代码，我们可以让外部模块调用的时候不执行我们的调试代码，但是如果我们想排查问题的时候，直接执行该模块文件，调试代码能够正常运行！

### 2. 使得打印结果更具可读性
```python
from pprint import pprint
pprint(df.head(10))
```
> 使用depth参数可以控制美观打印机递归处理嵌套数据结构的深度。输出中未包含的层次由一个省略号表示

### 3. 矩阵点乘`np.multiply()`与普通乘法`*`的区别
> 与乘法`*`相同

```python
import numpy as np
import pandas as pd
x1 = np.arange(9.0).reshape((3, 3))
x2 = np.arange(3.0)
x3 = pd.DataFrame(x1)
print(np.multiply(x1, x2))
print(x1*x2)
## 以上两项结果相同, 皆为矩阵的每一列和x2点乘

print(np.multiply(x1,x3))
print(x1*x3)
type(x1*x3)
## 以上两项结果相同, 皆为两个矩阵对应元素分别相乘
```

> 与乘法`*`不同

```python
x1 = [1,2,3,4,5]
x2 = [x * 10 for x in x1]
print(np.multiply(x1,2))
print(x1*2)
"""
---------------------------------------
以上两项结果不同, 分别为:
[ 2  4  6  8 10]
[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]
由此可见在进行点乘时, 如果数据结构存在变数
使用multiply是最为稳妥的方式
--------------------------------------
"""
```


### 4. 随机
1. 打乱顺序
```python
import random
lll = list(range(20))
random.shuffle(lll)
# shuffle方法对对象本身进行操作, 并不返回任何值
```

2. 从一个集合中随机抽出n个
```python
import random
### 从0~99中随机抽出10个数(无放回)
lll = random.sample(range(100),10)

### 从0~99中随机抽出10个数(有放回)
lll = random.choices(range(100),k=10)
```

3. 从某个分布中随机取数
```python
### 从一个均匀分布中取出n个数
lll = random.uniform(10, 20) # 均匀分布为 10<=n<=20

### 从[0,1]均匀分布中随机取一个数
lll = random.random()

### 从一个标准正态分布中取出n个数
lll = random.gauss(0,1)

```

### 5. 类的特殊方法
1. `__init__`
> - 类里面的这个方法负责初始化, 当实例化某类(创建一个类的对象)时, 就会自动调用该方法

> - e.g.

```python
# inside class Time

def __init__(self,hour=0,minute=0,second=0):
    self.hour = hour
    self.minute = minute
    self.second = second


# 运行时

time = Time()
# 这时 time.hour = 0
# 这时 time.minute = 0
# 这时 time.second = 0
```

2. `__str__`
> - 当打印一个对象时, 就会调用该方法

> - e.g.

```python
# inside class Time

def __str__(self):
    return '%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second)

# 运行时
time = Time(9,45)
print(time)
# 结果为: 09:45:00
```

3. `__add__`
> 当两个对象相加时, 就会调用此方法

### 6. 按照字典的value找key
```python
a = [{'a':10,'b':20},{'a':20,'b':10,'c':1}]

for y_j in a:
    print(max(y_j,key = y_j.get))  # 按照value得大小找最大
    print(max(y_j)) # 按照key的大小找最大

max_key = [max(y_j, key=y_j.get) for y_j in a] # 按照value取出最大的key
max_value = [a[j][max_key[j]] for j in range(len(max_key))] # 取出对应的value
```


### 7. `filter()`语法

`filter(function, sequence)`：
> 对sequence中的item依次执行function(item)，将执行结果为True的item组成一个List/String/Tuple（取决于sequence的类型）返回

```python
def f(x): return x % 2 != 0 and x % 3 != 0
filter(f, range(2, 25))
## 结果为：[5, 7, 11, 13, 17, 19, 23]

def f(x): return x != 'a'
filter(f, "abcdef")
## 结果为：'bcdef'
```

### 8. `map()`语法

`map(function, sequence)`:
> 对sequence中的item依次执行function(item)，将执行结果组成一个List返回

```python
def cube(x): return x*x*x
map(cube, range(1, 11))
## 结果为：[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]


def cube(x) : return x + x
map(cube , "abcde")
## 结果为：['aa', 'bb', 'cc', 'dd', 'ee']

## 另外map也支持多个sequence，这就要求function也支持相应数量的参数输入：
def add(x, y): return x+y
map(add, range(8), range(8))
## 结果为：[0, 2, 4, 6, 8, 10, 12, 14]
```


### 9. `reduce()`语法

`reduce(function, sequence, starting_value)`:
> 对sequence中的item顺序迭代调用function，如果有starting_value，还可以作为初始值调用，例如可以用来对List求和：

```python
def add(x,y): return x + y
reduce(add, range(1, 11))
## 结果为：55 （注：1+2+3+4+5+6+7+8+9+10）

reduce(add, range(1, 11), 20)
## 结果为：75 （注：1+2+3+4+5+6+7+8+9+10+20）
```


### 正则表达式的实际应用

[python帮助文件](https://docs.python.org/3.1/library/re.html)
1. 一个简单的例子
```python
import re
singleChars = ['A货','Huo','爱货']
alphanumericMatch = re.compile(r'[^A-z0-9]') ## 以A-z0-9开头的字符串不考虑
filteredSingleChars = list(filter(alphanumericMatch.match, singleChars))
## 结果为：['爱货']
```

> - `r" "` 或者` r' '`是要把后面的规则中的字符每一个都看成单独的符号：r"\n" is a two-character string containing '\\' and 'n', while "\n" is a one-character string containing a newline.

> - `^` 的意思是支取匹配第一个字符

> - 以上程序的意思是，去掉singleChars以A-Z，a-z，0-9开头的字符元素

